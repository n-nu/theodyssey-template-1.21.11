## Quick orientation

This repo is a Fabric Minecraft mod template (mod id `theodyssey`) using Fabric Loom and Java 21. Aim to keep changes minimal and follow existing package structure: `nanu4.odyssey` (mod entry), `nanu4.world` (world generation), and `nanu4.odyssey.mixin` (mixins).

## Big picture
- **Entrypoints**: see `src/main/resources/fabric.mod.json` — `main` -> `nanu4.odyssey.Theodyssey`, `client` -> `nanu4.odyssey.theodysseyClient`, `fabric-datagen` -> `nanu4.odyssey.TheodysseyDataGenerator`.
- **Runtime vs datagen**: runtime code lives under `src/main/java`. Data generation is wired by the `DataGeneratorEntrypoint` implementation in `TheodysseyDataGenerator` and registered with Loom's datagen tasks.
- **World gen**: world-generation classes live under `nanu4.world` (`ModConfiguredFeatures`, `ModPlacedFeatures`, `gen/ModWorldGeneration`). Registration happens via bootstrap calls from `Theodyssey`/datagen using `RegistryBuilder`.
- **Mixins**: mixin classes are under `nanu4.odyssey.mixin` and referenced by `theodyssey.mixins.json` (see `src/main/resources`). Example injection: `ExampleMixin` injects into `MinecraftServer.loadWorld()`.

## Build / run / dev workflow (Windows)
- Ensure JDK 21 is used (Gradle and `compileJava` configured for Java 21). The project sets `options.release = 21` and `sourceCompatibility = 21` in `build.gradle`.
- Common commands (run from repo root in PowerShell):

```powershell
.\gradlew.bat build
.\gradlew.bat runClient   # Launch a dev Minecraft client with the mod
.\gradlew.bat runServer   # Launch a dedicated server for testing
.\gradlew.bat runData     # (Loom datagen task) run fabric datagen entrypoint
```

- Output jar: `build/libs/` (sources JAR is generated by default).
- `processResources` expands `${version}` in `fabric.mod.json` from `project.version`.

## Project-specific conventions and patterns
- Use the `MOD_ID` constant from `Theodyssey.java` as the canonical mod id when registering items/blocks/keys.
- Logging: use `Theodyssey.LOGGER` (SLF4J) for consistent log prefixing.
- World-gen registration: prefer bootstrap methods in `ModConfiguredFeatures`/`ModPlacedFeatures` and call them from a single `ModWorldGeneration.generateModWorldGeneration()` helper (this pattern centralizes registration).
- Data generation: implement `DataGeneratorEntrypoint` and use `RegistryBuilder` in `buildRegistry` to register datagen registries (see `TheodysseyDataGenerator.java`).
- Mixins: place mixins in `nanu4.odyssey.mixin` and declare them in `theodyssey.mixins.json`; keep mixin methods minimal and prefer helper classes for complex logic.

## Integration points & dependencies
- Fabric Loader and Fabric API are provided via `build.gradle` dependencies; mappings use Yarn (`project.yarn_mappings`). Check `gradle.properties` to change versions.
- `fabric.mod.json` controls runtime entrypoints, dependencies, and mixins — editing it affects runtime loading immediately.

## Code examples to reference
- Mod initializer: `src/main/java/nanu4/odyssey/Theodyssey.java` (mod id, logger, world gen init).
- Datagen entrypoint: `src/main/java/nanu4/odyssey/TheodysseyDataGenerator.java` (implements `DataGeneratorEntrypoint`).
- Example mixin: `src/main/java/nanu4/odyssey/mixin/ExampleMixin.java` (shows injection style).

## When editing the project
- Keep package layout: put runtime game code under `nanu4.*`, keep world-gen code in `nanu4.world` to match bootstrap wiring.
- Update `fabric.mod.json` entrypoints when adding new runtime/datagen entry classes.
- If adding registries, follow the `RegistryBuilder` pattern used in `TheodysseyDataGenerator`.

## What AI agents should do first
1. Read `src/main/resources/fabric.mod.json` to understand entrypoints.
2. Inspect `Theodyssey.java` and `TheodysseyDataGenerator.java` for registration patterns.
3. Use `MOD_ID` constant when searching code for mod-scoped identifiers.
4. Run `./gradlew.bat runClient` locally to observe runtime behavior before making nontrivial API changes.

## Missing/unknowns to ask the human
- Confirm preferred Git branch for changes and whether publishing to a Maven repo is desired (publishing block in `build.gradle` is empty).
- Confirm if there are custom Gradle tasks or CI steps not present in the repo.

If anything here is unclear or you'd like more detail (CI, testing, or example contributions), tell me which area to expand.  
